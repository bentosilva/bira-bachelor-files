/* Generated By:JavaCC: Do not edit this line. Pascal.java */
import java.util.*;
import java.io.*;


        public class Pascal implements PascalConstants {

                static symbolTable st = new symbolTable();
                static int nivel_corr = 0;
                static int rotulo_atual = 1;
                static int endereco_atual = 0;
                static Integer sinal;

                /* precisaremos guardar os ??ltimos endere??os para alocar mem??ria para o case */
                static Stack enderecos = new Stack();

                /* m??todo que gera uma instru????o da MEPA, como visto em aula */
                public static void GERA(String label, String instrucao, String par1, String par2)
                {
                        String comando = "";
                        if ((label == null) || label.equals(""))
                                comando = "        ";
                        else
                                comando = label + ": ";

                        comando = comando + instrucao;

                        if (!((par1 == null) || par1.equals(""))) {
                                comando = comando + " " + par1;
                                if (!((par2 == null) || par2.equals("")))
                                        comando = comando + ", " + par2;
                        }

                        System.out.println(comando);
                }

                /* m??todo que gera um novo r??tulo ??nico, como visto em aula */
                public static String Proximo_Rotulo()
                {
                        return "L" + rotulo_atual++;
                }

                public static void main(String args[]) throws ParseException
                {
                        try {
                                Pascal pascal = new Pascal(System.in);
                                pascal.program();
                        } catch (ParseException e) {
                                System.out.println("Erro na an\ufffd\ufffdlise sint\ufffd\ufffdtica: " + e.toString());
                        } catch (Exception e) {
                                e.printStackTrace();
                                System.out.println(e.toString());
                        }
                }

  static final public void program() throws ParseException {
        Token nome_prog_principal;
    jj_consume_token(PROGRAM);
    nome_prog_principal = jj_consume_token(ID);
    jj_consume_token(PV);
                GERA(null, "INPP", null, null);
    bloco(nome_prog_principal.image, true);
    jj_consume_token(PONTO);
                GERA(null, "PARA", null, null);
    jj_consume_token(0);
  }

/* BLOCO:
 * O primeiro par??metro ?? o nome do bloco e ?? necess??rio para que
 *   ele gere os labels corretos. Se n??o for o bloco principal,
 *   o bloco n??o deve gerar ENPR e RTPR. As instru????es AMEM e DMEM
 *   s?? devem ser geradas se no bloco tiverem sido declaradas vari??veis.
 */
  static final public void bloco(String nome_bloco, boolean prog_principal) throws ParseException {
        int qtddVars = 0;
        symbol proc_info = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TYPE:
      parte_decl_tipo();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      qtddVars = parte_decl_vars();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
                if (prog_principal == true)
                        GERA(null, "DSVS", nome_bloco, null);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PROCEDURE:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      parte_decl_procs();
    }
                GERA(nome_bloco, "NADA", null, null);
                if (prog_principal == false) {
                        proc_info = st.busca(nome_bloco);
                        GERA(null, "ENPR", Integer.toString(proc_info.getNivel() + 1), null);
                }
                if (qtddVars > 0)
                        GERA(null, "AMEM", Integer.toString(qtddVars), null);
    comando_composto();
                if (qtddVars > 0)
                        GERA(null, "DMEM", Integer.toString(qtddVars), null);
                if (prog_principal == false)
                        GERA(null, "RTPR", Integer.toString(proc_info.getNivel() + 1), proc_info.getNParametros().toString());
  }

  static final public void parte_decl_tipo() throws ParseException {
    jj_consume_token(TYPE);
    label_2:
    while (true) {
      decl_tipo();
      jj_consume_token(PV);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
    }
  }

  static final public void decl_tipo() throws ParseException {
        ArrayList<symbol> nomes_enum;
        symbol oid;
        symbol otipo;
    oid = novo_id();
    jj_consume_token(EQ);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      otipo = tipo();
                st.setaAtributos(oid, "tipo", otipo.getTipo(), otipo.getNBytes(), null, nivel_corr, null, null, null, null);
      break;
    case PAR_ABRE:
      jj_consume_token(PAR_ABRE);
      nomes_enum = lista_identificadores();
      jj_consume_token(PAR_FECHA);
                for (int i = 0; i < nomes_enum.size(); i++)
                        st.setaAtributos(nomes_enum.get(i), "const", oid.getIdentificador(), 1, null, nivel_corr, null, null, i, null);
                st.setaAtributos(oid, "tipo", oid.getIdentificador(), 1, nomes_enum.size(), nivel_corr, nomes_enum, null, null, null);
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public int parte_decl_vars() throws ParseException {
        int qtddVars = 0, t;
    jj_consume_token(VAR);
    label_3:
    while (true) {
      t = decl_vars();
                                  qtddVars += t;
      jj_consume_token(PV);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_3;
      }
    }
          {if (true) return qtddVars;}
    throw new Error("Missing return statement in function");
  }

  static final public int decl_vars() throws ParseException {
        ArrayList<symbol> novas_variaveis, nomes_enum;
        symbol otipo;
    novas_variaveis = lista_identificadores();
    jj_consume_token(DOISPONTOS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      otipo = tipo();
                for (int i = 0; i < novas_variaveis.size(); i++)
                        st.setaAtributos(novas_variaveis.get(i), "var", otipo.getTipo(), otipo.getNBytes(), null, nivel_corr, null, endereco_atual++, null, "valor");
      break;
    case PAR_ABRE:
      jj_consume_token(PAR_ABRE);
      nomes_enum = lista_identificadores();
      jj_consume_token(PAR_FECHA);
                for (int i = 0; i < nomes_enum.size(); i++)
                        st.setaAtributos(nomes_enum.get(i), "const", nomes_enum.toString(), 1, null, nivel_corr, null, null, i, "valor");
                st.setaAtributos(st.insere(nomes_enum.toString()), "tipo", nomes_enum.toString(), 1, nomes_enum.size(), nivel_corr, nomes_enum, null, null, "valor");

                for (int i = 0; i < novas_variaveis.size(); i++)
                        st.setaAtributos(novas_variaveis.get(i), "var", nomes_enum.toString(), 1, nomes_enum.size(), nivel_corr, null, endereco_atual++, null, "valor");
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
          {if (true) return novas_variaveis.size();}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<symbol> lista_identificadores() throws ParseException {
        ArrayList<symbol> lista = new ArrayList<symbol>();
        symbol oid;
    oid = novo_id();
                          lista.add(oid);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      jj_consume_token(VIRGULA);
      oid = novo_id();
                                                                          lista.add(oid);
    }
          {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

  static final public void parte_decl_procs() throws ParseException {
    decl_proc();
  }

/* DECL_PROC:
 * Ao se entrar em um procedimento, o ??ltimo endere??o do n??vel anterior deve
 *   ser guardado pois precisaremos dele posteriormente para alocar uma vari??vel
 *   tempor??ria para o case.
 */
  static final public void decl_proc() throws ParseException {
        symbol proc;
        int nivel_proc = nivel_corr;
        ArrayList<symbol> lista = new ArrayList<symbol>();
    jj_consume_token(PROCEDURE);
    proc = novo_id();
                nivel_corr++;
                enderecos.push(new Integer(endereco_atual));
                endereco_atual = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PAR_ABRE:
      lista = parametros_formais();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(PV);
                st.setaAtributos(proc, "proc", null, null, lista.size(), nivel_proc, lista, null, null, null);
    bloco(proc.getIdentificador(), false);
    jj_consume_token(PV);
                nivel_corr--;
                endereco_atual = ((Integer) enderecos.pop()).intValue();
  }

  static final public ArrayList<symbol> parametros_formais() throws ParseException {
        ArrayList<symbol> lista = new ArrayList<symbol>(), l = new ArrayList<symbol>();
    jj_consume_token(PAR_ABRE);
    l = secao_parametros_formais();
                                                    lista.addAll(l);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PV:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      jj_consume_token(PV);
      l = secao_parametros_formais();
                                                                                                               lista.addAll(l);
    }
    jj_consume_token(PAR_FECHA);
                for (int i = 0; i < lista.size(); i++)
                        /* o endere??o do par??metro ?? negativo a partir de -3, decrescendo */
                        lista.get(i).setEndereco(i - lista.size() - 2);
                {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<symbol> secao_parametros_formais() throws ParseException {
        boolean tem_var = false;
        ArrayList<symbol> ids = new ArrayList<symbol>();
        symbol otipo;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      jj_consume_token(VAR);
                  tem_var = true;
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    ids = lista_identificadores();
    jj_consume_token(DOISPONTOS);
    otipo = tipo();
                for (int i = 0; i < ids.size(); i++)
                        st.setaAtributos(ids.get(i), "var", otipo.getIdentificador(), otipo.getNBytes(), null, nivel_corr, null, 0, null, tem_var ? "referencia" : "valor");
                {if (true) return ids;}
    throw new Error("Missing return statement in function");
  }

  static final public void comando_composto() throws ParseException {
    jj_consume_token(BEGIN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN:
    case CASE:
    case IF:
    case WHILE:
    case ID:
      comando();
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PV:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        jj_consume_token(PV);
        comando();
      }
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(END);
  }

  static final public void comando() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      comando_id();
      break;
    case BEGIN:
      comando_composto();
      break;
    case IF:
      comando_condicional_1();
      break;
    case CASE:
      comando_condicional_2();
      break;
    case WHILE:
      comando_repetitivo_1();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void comando_id() throws ParseException {
        Token id;
        symbol simbolo_valor;
        ArrayList<symbol> lista;
        symbol oid;
    id = jj_consume_token(ID);
                oid = st.busca(id.image);

                if (oid == null) {
                        System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo foi definido.");
                        System.exit(1);
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPATRIB:
      simbolo_valor = atribuicao();
                if (!oid.getCategoria().equals("var")) {
                        System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo \ufffd\ufffd uma vari\ufffd\ufffdvel.");
                        System.exit(1);
                }

                if (!simbolo_valor.getTipo().equals(oid.getTipo())) {
                        System.out.println("erro: os tipos da atribui\ufffd\ufffd\ufffd\ufffdo s\ufffd\ufffdo diferentes.");
                        System.exit(1);
                }
                /* o comando ?? de atribui????o e o armazenamento do valor calculado depende da classe de transfer??ncia da vari??vel que recebe o valor */
                if (oid.getClasseTransferencia().equals("referencia"))
                        GERA(null, "ARMI", Integer.toString(oid.getNivel()), oid.getEndereco().toString());
                else
                        GERA(null, "ARMZ", Integer.toString(oid.getNivel()), oid.getEndereco().toString());
      break;
    default:
      jj_la1[14] = jj_gen;
      lista = chamada_procedimento(oid);
                if (!oid.getCategoria().equals("proc")) {
                        System.out.println("erro: o identificador " + id.image + " n\ufffd\ufffdo \ufffd\ufffd um procedimento.");
                        System.exit(1);
                }
                if (!(oid.getIdentificador().equals("read")) && !(oid.getIdentificador().equals("write"))) {
                        /* procedimentos do programa */
                        for (int i = 0; i < lista.size(); i++) {
                                if (!lista.get(i).getTipo().equals(oid.getListaParametros().get(i).getTipo())) {
                                        System.out.println("erro: o par\ufffd\ufffdmetro " + (i+1) + " n\ufffd\ufffdo \ufffd\ufffd do tipo correto para o procedimento " + id.image + ".");
                                        System.exit(1);
                                }
                                if ((oid.getListaParametros().get(i).getClasseTransferencia().equals("referencia")) && (!lista.get(i).getCategoria().equals("var"))) {
                                                System.out.println("erro: o par\ufffd\ufffdmetro " + (i+1) + " \ufffd\ufffd uma express\ufffd\ufffdo e n\ufffd\ufffdo pode ser passado por refer\ufffd\ufffdncia para o procedimento " + id.image + ".");
                                                System.exit(1);
                                }
                        }
                        /* ap??s processar os argumentos do procedimento e se assegurar de que os tipos s??o v??lidos, chama o procedimento */
                        GERA(null, "CHPR", oid.getIdentificador(), null);
                }
    }
  }

  static final public symbol atribuicao() throws ParseException {
        symbol simbolo_expr;
    jj_consume_token(OPATRIB);
    simbolo_expr = expressao(false, false);
          {if (true) return simbolo_expr;}
    throw new Error("Missing return statement in function");
  }

  static final public ArrayList<symbol> chamada_procedimento(symbol procedimento) throws ParseException {
        ArrayList<symbol> lista = new ArrayList<symbol>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PAR_ABRE:
      jj_consume_token(PAR_ABRE);
      lista = lista_expressoes(procedimento);
      jj_consume_token(PAR_FECHA);
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
                {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

/* LISTA_EXPRESSOES:
 * Se o procedimento ?? um read, ent??o geramos um LEIT para cada
 *   par??metro processado pelo analisador sint??tico, seguido de um
 *   armazenamento dependendo da sua classe de transfer??ncia. O
 *   processamento das express??es ?? suprimido para que n??o gere
 *   instru????es incorretas (no caso ??nico do read, n??o queremos
 *   que o valor final da express??o fique na pilha).
 * Se o procedimento ?? um write, ent??o permitimos que o processamento
 *   das express??es continue normalmente e geramos um IMPR para cada
 *   par??metro passado para ela.
 * Caso contr??rio, o par??metro ?? colocado em uma lista que ser?? retornada
 *   para que os tipos sejam posteriormente checados.
 */
  static final public ArrayList<symbol> lista_expressoes(symbol procedimento) throws ParseException {
        ArrayList<symbol> lista = new ArrayList<symbol>();
        symbol osimbolo;
        int i = 0;
        boolean ehread = (procedimento.getIdentificador().equals("read"));
                if (!procedimento.getCategoria().equals("proc")) {
                        System.out.println("erro: o identificador " + procedimento.getIdentificador() + " n\ufffd\ufffdo \ufffd\ufffd um procedimento.");
                        System.exit(1);
                }
    osimbolo = expressao(ehread, procedimento.getListaParametros().get(i).getClasseTransferencia().equals("referencia"));
                if (procedimento.getIdentificador().equals("read")) {
                        GERA(null, "LEIT", null, null);
                        if (osimbolo.getCategoria().equals("var")) {
                                if (osimbolo.getClasseTransferencia().equals("referencia"))
                                        GERA(null, "ARMI", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                                else
                                        GERA(null, "ARMZ", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                        } else {
                                System.out.println("erro: todos os par\ufffd\ufffdmetros de read precisam ser vari\ufffd\ufffdveis (o " + (i+1) + "\ufffd\ufffd n\ufffd\ufffdo \ufffd\ufffd).");
                                System.exit(1);
                        }
                } else if (procedimento.getIdentificador().equals("write")) {
                        GERA(null, "IMPR", null, null);
                } else {
                        lista.add(osimbolo);
                        i++;
                }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VIRGULA:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_7;
      }
      jj_consume_token(VIRGULA);
      osimbolo = expressao(ehread, procedimento.getListaParametros().get(i).getClasseTransferencia().equals("referencia"));
                if (procedimento.getIdentificador().equals("read")) {
                        GERA(null, "LEIT", null, null);
                        if (osimbolo.getCategoria().equals("var")) {
                                if (osimbolo.getClasseTransferencia().equals("referencia"))
                                        GERA(null, "ARMI", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                                else
                                        GERA(null, "ARMZ", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                        } else {
                                System.out.println("erro: todos os par\ufffd\ufffdmetros de read precisam ser vari\ufffd\ufffdveis (o " + (i+1) + "\ufffd\ufffd n\ufffd\ufffdo \ufffd\ufffd).");
                                System.exit(1);
                        }
                } else if (procedimento.getIdentificador().equals("write")) {
                        if (osimbolo.getCategoria().equals("var")) {
                                if (osimbolo.getClasseTransferencia().equals("referencia"))
                                        GERA(null, "CRVI", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                                else
                                        GERA(null, "CRVL", Integer.toString(osimbolo.getNivel()), osimbolo.getEndereco().toString());
                                GERA(null, "IMPR", null, null);
                        } else
                                GERA(null, "IMPR", null, null);
                } else {
                        lista.add(osimbolo);
                        i++;
                }
    }
                {if (true) return lista;}
    throw new Error("Missing return statement in function");
  }

/* COMANDO_CONDICIONAL_1:
 * Se o comando for um if sem um else, ent??o precisamos apenas de um
 *   r??tulo (label_fim) para o final do corpo do if.
 * Se o comando for um if com o respectivo else, ent??o precisamos de
 *   dois r??tulos: um para o in??cio do corpo do else (label_else) e o
 *   outro para o final do comando todo.
 */
  static final public void comando_condicional_1() throws ParseException {
        symbol simbolo_expressao;
        String label_fim = Proximo_Rotulo();
        String label_else;
    jj_consume_token(IF);
    simbolo_expressao = expressao(false, false);
                if (!simbolo_expressao.getTipo().equals("boolean")) {
                        System.out.println("erro: \ufffd\ufffd necess\ufffd\ufffdria uma express\ufffd\ufffdo booleana para o comando condicional 'if'.");
                        System.exit(1);
                }
                GERA(null, "DSVF", label_fim, null);
    jj_consume_token(THEN);
    comando();
    if (jj_2_1(2147483647)) {
      jj_consume_token(ELSE);
                label_else = label_fim;
                label_fim = Proximo_Rotulo();
                GERA(null, "DSVS", label_fim, null);
                GERA(label_else, "NADA", null, null);
      comando();
    } else {
      ;
    }
                GERA(label_fim, "NADA", null, null);
  }

/* COMANDO_CONDICIONAL_2:
 * J?? que o case permite que seja fornecida uma express??o num??rica
 *   e o comando de desvio condicional da MEPA consome o valor do topo
 *   da pilha, precisamos armazenar uma c??pia do resultado desta express??o
 *   para podermos comparar m??ltiplas vezes com as cl??usulas.
 * Para isso, alocamos uma posi????o de mem??ria e recuperamos uma c??pia do
 *   valor armazenado nela a cada compara????o que precisamos fazer.
 * Ao final, desalocamos a mem??ria.
 */
  static final public void comando_condicional_2() throws ParseException {
        symbol simbolo_expressao;
        Token id, num;
        symbol oid;
        String fim_case = Proximo_Rotulo(), label = Proximo_Rotulo();
        int t_endereco;
                /* aloca uma posi????o tempor??ria de mem??ria para armazenar o valor da express??o */
                GERA(null, "AMEM", "1", null);
                t_endereco = endereco_atual++;
    jj_consume_token(CASE);
    simbolo_expressao = expressao(false, false);
                if (simbolo_expressao.getTipo().equals("boolean")) {
                        System.out.println("erro: \ufffd\ufffd necess\ufffd\ufffdrio um valor num\ufffd\ufffdrico para o comando condicional 'case'.");
                        System.exit(1);
                }
                GERA(null, "ARMZ", Integer.toString(nivel_corr), Integer.toString(t_endereco));
    jj_consume_token(OF);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ID:
      case NUMERO:
        ;
        break;
      default:
        jj_la1[17] = jj_gen;
        break label_8;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMERO:
        num = jj_consume_token(NUMERO);
                        if  (!simbolo_expressao.getTipo().equals("integer")) {
                                System.out.println("erro: valores num\ufffd\ufffdricos s\ufffd\ufffdo apensa v\ufffd\ufffdlidos para express\ufffd\ufffdes num\ufffd\ufffdricas no comando condicional 'case'.");
                                System.exit(1);
                        }
                        GERA(null, "CRCT", num.image, null);
        break;
      case ID:
        id = jj_consume_token(ID);
                        if (simbolo_expressao.getTipo().equals("integer")) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd v\ufffd\ufffdlido usar identificadores quando o comando 'case' tem uma express\ufffd\ufffdo num\ufffd\ufffdrica");
                                System.exit(1);
                        }

                        oid = st.busca(id.image);

                        if (oid == null) {
                                System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo foi definido.");
                                System.exit(1);
                        }

                        if  (!simbolo_expressao.getTipo().equals(oid.getTipo())) {
                                System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo faz parte do enum \u005c"" + simbolo_expressao.getTipo() + "\u005c".");
                                System.exit(1);
                        }

                        if (oid.getCategoria().equals("const"))
                                GERA(null, "CRCT", Integer.toString(oid.getValor()), null);
                        else {
                                if (oid.getClasseTransferencia().equals("referencia"))
                                        GERA(null, "CRVI", Integer.toString(oid.getNivel()), oid.getEndereco().toString());
                                else
                                        GERA(null, "CRVL", Integer.toString(oid.getNivel()), oid.getEndereco().toString());
                        }
        break;
      default:
        jj_la1[18] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(DOISPONTOS);
                        GERA(null, "CRVL", Integer.toString(nivel_corr), Integer.toString(t_endereco));
                        GERA(null, "CMIG", null, null);
                        GERA(null, "DSVF", label, null);
      comando();
      jj_consume_token(PV);
                        GERA(null, "DSVS", fim_case, null);
                        GERA(label, "NADA", null, null);
                        label = Proximo_Rotulo();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      comando();
      break;
    default:
      jj_la1[19] = jj_gen;
      ;
    }
    jj_consume_token(END);
                GERA(fim_case, "NADA", null, null);
                endereco_atual--;
                GERA(null, "DMEM", "1", null);
  }

/* COMANDO_REPETITIVO_1:
 * Este comando exige o uso de dois r??tulos, um para o in??cio do comando
 *   (ou seja, antes do teste) e outro para a instru????o logo ap??s o corpo
 *   do while.
 */
  static final public void comando_repetitivo_1() throws ParseException {
        symbol simbolo_expressao;
        String label_while = Proximo_Rotulo();
        String label_fim = Proximo_Rotulo();
                GERA(label_while, "NADA", null, null);
    jj_consume_token(WHILE);
    simbolo_expressao = expressao(false, false);
                if (!simbolo_expressao.getTipo().equals("boolean")) {
                        System.out.println("erro: \ufffd\ufffd necess\ufffd\ufffdria uma express\ufffd\ufffdo booleana para o la\ufffd\ufffdo 'while'.");
                        System.exit(1);
                }
                GERA(null, "DSVF", label_fim, null);
    jj_consume_token(DO);
    comando();
                GERA(null, "DSVS", label_while, null);
                GERA(label_fim, "NADA", null, null);
  }

/* EXPRESSAO:
 * Para que o c??digo gerado seja em p??s-ordem, como ?? exigido pela MEPA,
 *   esta parte guarda a informa????o de qual opera????o foi lida e gera o
 *   respectivo c??digo apenas ap??s o processamento da segunda express??o.
 */
  static final public symbol expressao(boolean ehread, boolean referencia) throws ParseException {
        symbol simbolo_expressao_simples1, simbolo_expressao_simples2;
        boolean eq, composto = false;
        /* vari??vel que ir?? retornar informa????es da express??o, como categoria (especial "expressao"), tipo e classe de transfer??ncia*/
        symbol expr = new symbol();
        int op = 0;
    simbolo_expressao_simples1 = expressao_simples(ehread, referencia);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
    case LE:
    case GT:
    case GE:
    case EQ:
    case NE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
                         eq = true; op = 1;
        break;
      case NE:
        jj_consume_token(NE);
                         eq = true; op = 2;
        break;
      case LT:
        jj_consume_token(LT);
                         eq = false; op = 3;
        break;
      case LE:
        jj_consume_token(LE);
                         eq = false; op = 4;
        break;
      case GT:
        jj_consume_token(GT);
                         eq = false; op = 5;
        break;
      case GE:
        jj_consume_token(GE);
                         eq = false; op = 6;
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                    composto = true;
      simbolo_expressao_simples2 = expressao_simples(ehread, referencia);
                        if (eq) {
                                if (!simbolo_expressao_simples1.getTipo().equals(simbolo_expressao_simples2.getTipo())) {
                                        System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel comparar dois tipos diferentes.");
                                        System.exit(1);
                                }
                        } else {
                                if (!simbolo_expressao_simples1.getTipo().equals("integer") || !simbolo_expressao_simples2.getTipo().equals("integer")) {
                                        System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel utilizar este operando para estes tipos.");
                                        System.exit(1);
                                }
                        }
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
                /* gera????o de c??digo em p??s-ordem: operador depois dos operandos */
                switch (op) {
                        case 1:
                                GERA(null, "CMIG", null, null);
                                break;
                        case 2:
                                GERA(null, "CMDG", null, null);
                                break;
                        case 3:
                                GERA(null, "CMME", null, null);
                                break;
                        case 4:
                                GERA(null, "CMEG", null, null);
                                break;
                        case 5:
                                GERA(null, "CMMA", null, null);
                                break;
                        case 6:
                                GERA(null, "CMAG", null, null);
                                break;
                }

                if (composto) {
                        expr.setCategoria("expressao");
                        expr.setTipo("boolean");
                        expr.setClasseTransferencia("valor");
                        expr.setListaParametros(new ArrayList<symbol>());
                        {if (true) return expr;}
                } else
                        {if (true) return simbolo_expressao_simples1;}
    throw new Error("Missing return statement in function");
  }

/* EXPRESSAO_SIMPLES:
 * Para que o c??digo gerado seja em p??s-ordem, como ?? exigido pela MEPA,
 *   esta parte guarda a informa????o de qual opera????o foi lida e gera o
 *   respectivo c??digo apenas ap??s o processamento da segunda express??o.
 */
  static final public symbol expressao_simples(boolean ehread, boolean referencia) throws ParseException {
        symbol simbolo_termo1, simbolo_termo2;
        boolean arit = true, sinal = false, composto = false;
        /* vari??vel que ir?? retornar informa????es da express??o, como categoria (especial "expressao"), tipo e classe de transfer??ncia*/
        symbol expr = new symbol();
        int op = 0;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOMA:
    case SUBTRACAO:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SOMA:
        jj_consume_token(SOMA);
        break;
      case SUBTRACAO:
        jj_consume_token(SUBTRACAO);
        break;
      default:
        jj_la1[22] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                     sinal = true;
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    simbolo_termo1 = termo(ehread, referencia);
                if (sinal && !simbolo_termo1.getTipo().equals("integer")) {
                        System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar o sinal antes de termos n\ufffd\ufffdo inteiros.");
                        System.exit(1);
                }
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SOMA:
      case SUBTRACAO:
      case OR:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SOMA:
        jj_consume_token(SOMA);
                           arit = true; op = 1;
        break;
      case SUBTRACAO:
        jj_consume_token(SUBTRACAO);
                                arit = true; op = 2;
        break;
      case OR:
        jj_consume_token(OR);
                         arit = false; op = 3;
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                     composto = true;
      simbolo_termo2 = termo(ehread, referencia);
                        if (!simbolo_termo2.getTipo().equals("integer") && !simbolo_termo2.getTipo().equals("boolean")) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes l\ufffd\ufffdgicas ou aritm\ufffd\ufffdticas em tipos n\ufffd\ufffdo booleanos ou inteiros, respectivamente.");
                                System.exit(1);
                        }

                        if (arit && (!simbolo_termo1.getTipo().equals("integer") || !simbolo_termo2.getTipo().equals("integer"))) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes aritm\ufffd\ufffdticas em tipos n\ufffd\ufffdo inteiros.");
                                System.exit(1);
                        }

                        if (!arit && (!simbolo_termo1.getTipo().equals("boolean") || !simbolo_termo2.getTipo().equals("boolean"))) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes l\ufffd\ufffdgicas em tipos n\ufffd\ufffdo booleanos.");
                                System.exit(1);
                        }
    }
                /* gera????o de c??digo em p??s-ordem: operador depois dos operandos */
                switch (op) {
                        case 1:
                                GERA(null, "SOMA", null, null);
                                break;
                        case 2:
                                GERA(null, "SUBT", null, null);
                                break;
                        case 3:
                                GERA(null, "DISJ", null, null);
                                break;
                }
                if (composto) {
                        expr.setCategoria("expressao");
                        expr.setClasseTransferencia("valor");
                        expr.setListaParametros(new ArrayList<symbol>());
                        if (arit)
                                expr.setTipo("integer");
                        else
                                expr.setTipo("boolean");
                        {if (true) return expr;}
                } else
                        {if (true) return simbolo_termo1;}
    throw new Error("Missing return statement in function");
  }

/* TERMO:
 * Para que o c??digo gerado seja em p??s-ordem, como ?? exigido pela MEPA,
 *   esta parte guarda a informa????o de qual opera????o foi lida e gera o
 *   respectivo c??digo apenas ap??s o processamento da segunda express??o.
 */
  static final public symbol termo(boolean ehread, boolean referencia) throws ParseException {
        symbol simbolo_fator1, simbolo_fator2;
        boolean arit = true, composto = false;
        /* vari??vel que ir?? retornar informa????es da express??o, como categoria (especial "expressao"), tipo e classe de transfer??ncia*/
        symbol expr = new symbol();
        int op = 0;
    simbolo_fator1 = fator(ehread, referencia);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLICACAO:
      case DIV:
      case AND:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MULTIPLICACAO:
        jj_consume_token(MULTIPLICACAO);
                                    arit = true; op = 1;
        break;
      case DIV:
        jj_consume_token(DIV);
                          arit = true; op = 2;
        break;
      case AND:
        jj_consume_token(AND);
                          arit = false; op = 3;
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                      composto = true;
      simbolo_fator2 = fator(ehread, referencia);
                        if (!simbolo_fator2.getTipo().equals("integer") && !simbolo_fator2.getTipo().equals("boolean")) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes l\ufffd\ufffdgicas ou aritm\ufffd\ufffdticas em tipos n\ufffd\ufffdo booleanos ou inteiros, respectivamente.");
                                System.exit(1);
                        }

                        if (arit && (!simbolo_fator1.getTipo().equals("integer") || !simbolo_fator2.getTipo().equals("integer"))) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes aritm\ufffd\ufffdticas em tipos n\ufffd\ufffdo inteiros.");
                                System.exit(1);
                        }

                        if (!arit && (!simbolo_fator1.getTipo().equals("boolean") || !simbolo_fator2.getTipo().equals("boolean"))) {
                                System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar opera\ufffd\ufffd\ufffd\ufffdes l\ufffd\ufffdgicas em tipos n\ufffd\ufffdo booleanos.");
                                System.exit(1);
                        }
    }
                /* gera????o de c??digo em p??s-ordem: operador depois dos operandos */
                switch (op) {
                        case 1:
                                GERA(null, "MULT", null, null);
                                break;
                        case 2:
                                GERA(null, "DIV", null, null);
                                break;
                        case 3:
                                GERA(null, "CONJ", null, null);
                                break;
                }
                if (composto) {
                        expr.setCategoria("expressao");
                        expr.setClasseTransferencia("valor");
                        expr.setListaParametros(new ArrayList<symbol>());
                        if (arit)
                                expr.setTipo("integer");
                        else
                                expr.setTipo("boolean");
                        {if (true) return expr;}
                } else
                        {if (true) return simbolo_fator1;}
    throw new Error("Missing return statement in function");
  }

/* FATOR:
 * Para que o c??digo gerado seja em p??s-ordem, como ?? exigido pela MEPA,
 *   esta parte guarda a informa????o de qual opera????o foi lida e gera o
 *   respectivo c??digo apenas ap??s o processamento da segunda express??o.
 */
  static final public symbol fator(boolean ehread, boolean referencia) throws ParseException {
        symbol simbolo_coisa;
        Token num;
        /* vari??vel que ir?? retornar informa????es da express??o, como categoria (especial "expressao"), tipo e classe de transfer??ncia*/
        symbol expr = new symbol();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      simbolo_coisa = variavel();
                if (simbolo_coisa.getCategoria().equals("const"))
                        GERA(null, "CRCT", simbolo_coisa.getValor().toString(), null);
                else if (simbolo_coisa.getCategoria().equals("var")) {
                        /* se esta expressao vier da lista de par??metros de um read, n??o carregue o resultado na pilha */
                        if (!ehread) {
                                /* Esta parte leva em considera????o a classe de transfer??ncia da vari??vel lida (simbolo_coisa) e
				 * a classe de transfer??ncia do que ir?? receber o seu valor (referencia) na hora de gerar a instru????o correta.
				 */
                                if (simbolo_coisa.getClasseTransferencia().equals("referencia")) {
                                        if (referencia)
                                                GERA(null, "CREN", Integer.toString(simbolo_coisa.getNivel()), simbolo_coisa.getEndereco().toString());
                                        else
                                                GERA(null, "CRVI", Integer.toString(simbolo_coisa.getNivel()), simbolo_coisa.getEndereco().toString());
                                } else {
                                        if (referencia)
                                                GERA(null, "CREN", Integer.toString(simbolo_coisa.getNivel()), simbolo_coisa.getEndereco().toString());
                                        else
                                                GERA(null, "CRVL", Integer.toString(simbolo_coisa.getNivel()), simbolo_coisa.getEndereco().toString());
                                }
                        }
                }
                {if (true) return simbolo_coisa;}
      break;
    case NUMERO:
      num = jj_consume_token(NUMERO);
                GERA(null, "CRCT", num.image, null);
                expr.setCategoria("expressao");
                expr.setClasseTransferencia("valor");
                expr.setListaParametros(new ArrayList<symbol>());
                expr.setTipo("integer");
                {if (true) return expr;}
      break;
    case PAR_ABRE:
      jj_consume_token(PAR_ABRE);
      simbolo_coisa = expressao(ehread, referencia);
      jj_consume_token(PAR_FECHA);
                                                                                 {if (true) return simbolo_coisa;}
      break;
    case NOT:
      jj_consume_token(NOT);
      simbolo_coisa = fator(ehread, referencia);
                if (!simbolo_coisa.getTipo().equals("boolean")) {
                        System.out.println("erro: n\ufffd\ufffdo \ufffd\ufffd poss\ufffd\ufffdvel usar 'not' em express\ufffd\ufffdes n\ufffd\ufffdo-booleanas.");
                        System.exit(1);
                }
                GERA(null, "NEGA", null, null);
                {if (true) return simbolo_coisa;}
      break;
    default:
      jj_la1[28] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public symbol variavel() throws ParseException {
        Token id;
        symbol avar;
    id = jj_consume_token(ID);
                avar = st.busca(id.image);

                if (avar == null) {
                        System.out.println("erro: a vari\ufffd\ufffdvel \u005c"" + id.image + "\u005c" n\ufffd\ufffdo foi definida.");
                        System.exit(1);
                }

                if (!avar.getCategoria().equals("var") && !avar.getCategoria().equals("const") && !avar.getCategoria().equals("enum")) {
                        System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo \ufffd\ufffd uma vari\ufffd\ufffdvel.");
                        System.exit(1);
                }

                {if (true) return avar;}
    throw new Error("Missing return statement in function");
  }

  static final public symbol tipo() throws ParseException {
        Token id;
        symbol otipo;
    id = jj_consume_token(ID);
                otipo = st.busca(id.image);

                if (otipo == null) {
                        System.out.println("erro: o tipo \u005c"" + id.image + "\u005c" n\ufffd\ufffdo foi definido.");
                        System.exit(1);
                }

                if (!otipo.getCategoria().equals("tipo")) {
                        System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" n\ufffd\ufffdo \ufffd\ufffd um tipo.");
                        System.exit(1);
                }

                {if (true) return otipo;}
    throw new Error("Missing return statement in function");
  }

  static final public symbol novo_id() throws ParseException {
        Token id;
        symbol oid;
    id = jj_consume_token(ID);
                oid = st.busca(id.image);

                if (oid != null) {
                        System.out.println("erro: o identificador \u005c"" + id.image + "\u005c" j\ufffd\ufffd foi definido para um " + oid.getTipo() + " e n\ufffd\ufffdo pode ser redefinido.");
                        System.exit(1);
                }

                oid = st.insere(id.image);

                {if (true) return oid;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_3_1() {
    if (jj_scan_token(ELSE)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public PascalTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[29];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x1000000,0x2000000,0x0,0x200000,0x0,0x200000,0x1000,0x200000,0x2000,0x1000000,0x2000,0x14000000,0x14000000,0x800,0x200000,0x1000,0x0,0x0,0x0,0x1f8000,0x1f8000,0x180,0x180,0x180,0x180,0x600,0x600,0x80200000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x80,0x0,0x0,0x100,0x100,0x100,0x100,0x0,0x0,0x0,0x0,0x0,0x109,0x109,0x0,0x0,0x0,0x500,0x500,0x4,0x0,0x0,0x0,0x0,0x40,0x40,0x20,0x20,0x500,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[1];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Pascal(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Pascal(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new PascalTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Pascal(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new PascalTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Pascal(PascalTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(PascalTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 29; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[44];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 29; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 44; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 1; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

        }

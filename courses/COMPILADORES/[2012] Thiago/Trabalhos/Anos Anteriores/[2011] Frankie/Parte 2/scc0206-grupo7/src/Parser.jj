/*
	De acordo com o compilador, temos 4 pontos que são LL1
Warning: Choice conflict in (...)* construct at line 208, column 23.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: ";"
         Consider using a lookahead of 2 or more for nested expansion.
Warning: Choice conflict in [...] construct at line 293, column 17.
         Expansion nested within construct and expansion following construct
         have common prefixes, one of which is: "else"
         Consider using a lookahead of 2 or more for nested expansion.
*/

PARSER_BEGIN(Parser)


	public class Parser{

		public static void main(String[] args){

			Parser parser = new Parser(System.in);
			
			boolean maxIdentifier = false;
			boolean maxInt = false;

			
			while(true){

				try {
//					  parser.parser();
					  parser.Programa();
				} catch (ParseException ex) {

					System.out.println(ex.getMessage());
					System.exit(-1);

				} catch (TokenMgrError ex) {
					System.out.println(ex.getMessage());
					System.exit(-1);
				}
		}
	}
}
PARSER_END(Parser)

/* Eliminando caracteres despreziveis */
SKIP: {  " "|
		"\r"|
		"\t"|
		"\n"| 
		 <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>|  
		 <"{"  (~["}"])*  "}">
		}

/* Palavras reservadas */
TOKEN: { <PROGRAM: "program"> }
TOKEN: { <BOOLEAN: "boolean"> }
TOKEN: { <INT: "int"> } //no primeiro trabalho INT tava passando como ID 
TOKEN: { <PROCEDURE: "procedure"> }
TOKEN: { <VAR: "var"> }

/*Identificadores
TOKEN: { <READ: "read"> }
TOKEN: { <WRITE: "write"> }
TOKEN: { <TRUE: "true"> }
TOKEN: { <FALSE: "false"> }*/
TOKEN: { <BEGIN: "begin"> }
TOKEN: { <END: "end"> }
TOKEN: { <IF: "if"> }
TOKEN: { <ELSE: "else"> }
TOKEN: { <WHILE: "while"> }
TOKEN: { <OR: "or"> }
TOKEN: { <DIV: "div"> }
TOKEN: { <NOT: "not"> }
TOKEN: { <AND: "and"> }

/* Simbolos */
TOKEN: { <GREATER: ">"> }
TOKEN: { <GREATEREQ: ">="> }
TOKEN: { <NOTEQUAL: "<>"> }
TOKEN: { <EQUAL: "="> }
TOKEN: { <LESSER: "<"> }
TOKEN: { <LESSEREQ: "<="> }
TOKEN: { <PLUS: "+"> }
TOKEN: { <MINUS: "-"> }
TOKEN: { <STAR: "*"> }
TOKEN: { <SEMICOLON: ";"> }
TOKEN: { <COMMA: ","> }
TOKEN: { <DOT: "."> }
TOKEN: { <LPAR: "("> }
TOKEN: { <RPAR: ")"> }
//TOKEN: { <LBR: "{"> }
//TOKEN: { <RBR: "}"> }
TOKEN: { <ASSIGNMENT: ":="> }
TOKEN: { <COLON: ":"> }
TOKEN: { <TESTE: "@">}


/* Extensao grupo */
TOKEN: { <UNION: "union"> }

/* Tokens auxiliares */
TOKEN: { <#LETTER: ["a"-"z"]|["A"-"Z"]> }
TOKEN: { <#DIGIT: ["0"-"9"]> }

/* Inteiros */
TOKEN: { <NUMBER: (<DIGIT>)+> } 

/* Identificadores */
TOKEN: { <ID: "read"|"write"|"true"|"false"|(<LETTER> | "_")(<LETTER> | <DIGIT> | "_")*> }

/* Parser */
void parser() throws TokenMgrError, ParseException :
{
	Token t;
}
{
		t=<PROGRAM>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"PROGRAM | "+t.toString()); } |
		t=<BOOLEAN>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"BOOLEAN | "+t.toString()); } |
		t=<INT>			{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"INT | "+t.toString()); } |
		t=<PROCEDURE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"PROCEDURE | "+t.toString()); } |
		t=<VAR>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"VAR | "+t.toString()); } |

/* Identificadores
		t=<READ>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"READ | "+t.toString()); } |
		t=<WRITE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"WRITE | "+t.toString()); } |
		t=<TRUE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"TRUE | "+t.toString()); } |
		t=<FALSE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"FALSE | "+t.toString());} | */
		t=<BEGIN>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"BEGIN | "+t.toString());} |
		t=<END>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"END | "+t.toString());} |
		t=<IF>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"IF | "+t.toString());} |
		t=<ELSE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"ELSE | "+t.toString());} |
		t=<WHILE>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"WHILE | "+t.toString());} |
		t=<AND>	{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"AND | "+t.toString()); } |
		t=<OR>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"OR | "+t.toString());} |
		t=<DIV>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"DIV | "+t.toString());} |
		t=<NOT>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"NOT | "+t.toString());} |

/* Simbolos */
		t=<GREATER>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"GREATER | "+t.toString());} |
		t=<GREATEREQ>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"GREATEREQ | "+t.toString());} |
		t=<NOTEQUAL>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"NOTEQUAL | "+t.toString());} |
		t=<EQUAL>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"EQUAL | "+t.toString());} |
		t=<LESSER>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"LESSER | "+t.toString());} |
		t=<LESSEREQ>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"LESSEREQ | "+t.toString());} |
		t=<PLUS>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"PLUS | "+t.toString());} |
		t=<MINUS>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"MINUS | "+t.toString());} |
		t=<STAR>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"STAR | "+t.toString());} |
		t=<SEMICOLON>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"SEMICOLON | "+t.toString());} |
		t=<COMMA>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"COMMA | "+t.toString());} |
		t=<DOT>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"DOT | "+t.toString());} |
		t=<LPAR>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"LPAR | "+t.toString());} |
		t=<RPAR>		{ System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"RPAR | "+t.toString());} |
		t=<ASSIGNMENT> { System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"ASSIGMENT | "+t.toString());} |
		t=<COLON> 	{System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"COLON | "+t.toString()); }|




/*Extens‹o grupo */
		t=<UNION>		{System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"UNION | "+t.toString());} |

/* Inteiros */
		t=<NUMBER>{ 

			try{
		
				int size = Integer.parseInt(t.toString());	

				if(size < 32767) System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"NUMBER | "+t.toString());

				else throw new NumberFormatException();
			}	
			catch (NumberFormatException e){ 
			
			System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"NUMBER "+t.toString()+" Ž maior do que o permitido (32767)");
			
			}
			
			} |

/* Identificadores */
		t=<ID>			{ 
		
				if(t.endColumn - t.beginColumn < 33) System.out.println("@("+t.beginLine+","+t.beginColumn+") "+"ID |"+t.toString());
				else System.out.println("@("+t.beginLine+","+t.beginColumn+")"+" : ID "+t.toString()+" Ž maior do que o permitido (32 caracteres)");
				
				} |

		<EOF>			{ System.exit(0); }



}

void Programa() : {}
{
	<PROGRAM> <ID> <SEMICOLON>
	Bloco() <DOT> <EOF>
}

void Bloco(): {}
{
	[ParteDeDeclaracoesDeVariaveis()][ParteDeDeclaracoesDeProcedimentos()]ComandoComposto()
}

void ParteDeDeclaracoesDeVariaveis(): {}
{
(	Declaration() <SEMICOLON>)+
}

void Declaration(): {}
{
	(DeclarationSpecifiers()DeclaratorList() | <UNION> <ID> <BEGIN> ParteDeDeclaracoesDeVariaveis() <END> )
}

void DeclarationSpecifiers(): {}
{
	TypeSpecifier()
}

void TypeSpecifier(): {}
{
	(<BOOLEAN>|<INT>)
}

void DeclaratorList(): {}
{
	<ID> (<COMMA> <ID>)* 
}

void ParteDeDeclaracoesDeProcedimentos(): {}
{
//Não tá deixando a repetição de 0 ou mais vezes
	(DeclaracaoDeProcedimento()<SEMICOLON>)+
}

void DeclaracaoDeProcedimento(): {}
{
	<PROCEDURE>  <ID>
	  [ParametrosFormais()]<SEMICOLON>Bloco()
}

void ParametrosFormais(): {}
{
	<LPAR>SecaoDeParametrosFormais() (<SEMICOLON> SecaoDeParametrosFormais())* <RPAR>
}

void SecaoDeParametrosFormais(): {}
{
	[<VAR>] DeclaratorList() <COLON> ( TypeSpecifier() | <UNION> )
}

void ComandoComposto(): {}
{
//não tá sabendo quando sair do laço de repetição
	//<BEGIN> Comando() (<SEMICOLON> Comando() )* <END>
	<BEGIN> Comando() (<SEMICOLON>Comando())* <END>
}

void Comando(): {}
{
//código alterado para ficar LL(1)
	<ID> TipoComando() |
	ComandoComposto() |
	ComandoCondicional1() |
	ComandoRepetitivo1() 
}

//código alterado para tratar procedimento pré-definido write('string')
void TipoComando(): {}
{  //atribuicao                  //chamada de procedimento
	[<DOT><ID>]<ASSIGNMENT> Expressao()  //<SEMICOLON> 
   | [<LPAR> ListaDeExpressoes() <RPAR> ] // <SEMICOLON>
}

void ComandoCondicional1(): {}
{
	<IF> <LPAR>Expressao()<RPAR> Comando()
		[<ELSE> Comando()]
}

void ComandoRepetitivo1(): {}
{
	<WHILE> <LPAR> Expressao()  <RPAR> Comando()
}

void Expressao(): {}
{
	ExpressaoSimples() [Relacao() ExpressaoSimples()]
}

void Relacao(): {}
{
	<EQUAL> | <NOTEQUAL> |  <LESSER> | <GREATER> | <LESSEREQ> | <GREATEREQ>
}

void ExpressaoSimples(): {}
{
	[<PLUS>|<MINUS>] Termo() ((<PLUS>|<MINUS>|<OR>)Termo())*
}

void Termo(): {}
{
	Fator() ((<STAR>|<DIV>|<AND>)Fator())*
}

void Fator(): {}
{
	Variavel() | <NUMBER> | <LPAR> Expressao() <RPAR> | <NOT> Fator()
}

void Variavel(): {}
{
	<ID> (<DOT> <ID>)*
}

void ListaDeExpressoes(): {}
{
	Expressao() (<COMMA> Expressao())*
}

